{"version":3,"sources":["../../src/adapters/RxClient.js"],"names":["util","RxClient","client","_client","_txLevel","_savedTxLevel","_errorSource","undefined","_connectSource","_endSource","_querySource","log","of","fromEvent","take","subscribe","error","_cleanup","complete","connected","connect","bindNodeCallback","do","publishReplay","refCount","end","concatMap","queryText","values","projectFunction","query","_restoreLevel","source","map","projectedValue","result","concatAll","rows","slice","shift","from","mapTo","begin","ignoreElements","force","commit","rollback","connection","stream","readyState"],"mappings":"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","file":"RxClient.js","sourcesContent":["import assert from 'assert'\nimport { Client } from 'pg'\nimport { Observable } from 'rxjs'\nimport isFunction from 'lodash.isfunction'\nimport { RxClientError } from '../errors'\nimport * as util from '../util'\n\n/**\n * Standalone adapter for `node-postgres` {@link Client} class with Reactive API.\n *\n * @todo Try all examples! and add tests to cover use cases from examples.\n *\n * @example <caption>Basic usage</caption>\n * import { Client } from 'pg'\n * import { Observable } from 'rxjs'\n * import { RxClient } from 'rxjs-postgres'\n *\n * // Instantiate adapter with node-postgres Client instance\n * let rxClient = new RxClient(new Client({\n *   database: 'postgres',\n *   user: 'postgres'\n * }))\n *\n * // get multiple records from the database (connection will be opened automatically on the first query call)\n * rxClient.queryRowsFlat('select * from main'))\n *   .subscribe(\n *     row => console.log('NEXT', row),\n *     err => console.error('ERROR', err.stack),\n *     () => console.log('COMPLETE')\n *   )\n *\n * @see {@link RxPool}\n * @see {@link Client}\n *\n * @todo Try to use rxjs Subject behind the scene as single source of values, subscribe it to each async operation\n *    and manually emit results for it's observers, manually complete after closing connection etc...\n */\nexport default class RxClient {\n  /**\n   * Creates new RxClient instance.\n   *\n   * @example <caption>Initialization</caption>\n   * import { Client } from 'pg'\n   * import { RxClient } from 'rxjs-postgres'\n   *\n   * const rxClient = new RxClient(new Client())\n   * // now you are ready to work with PostgreSQL\n   * // load some record\n   * rxClient.queryRow('select * from main where id = $1', [ 1 ])\n   *   // then load some additional related records\n   *   .flatMap(\n   *     mainRow => rxClient.queryRows(\n   *       'select * from child where main_id = $1',\n   *       [ mainRow.id ]\n   *     ),\n   *     (mainRow, children) => ({ ...mainRow, children })\n   *   )\n   *   .subscribe(\n   *     mainRow => console.log('NEXT', mainRow),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#connect}\n   * @see {@link RxClient#end}\n   * @see {@link RxClient#query}\n   *\n   * @param {Client} client Instance of `node-postgres` Client type.\n   *\n   * @throws {RxClientError} Throws when called with invalid arguments.\n   * @throws {TypeError} Throws when called as function.\n   */\n  constructor (client) {\n    if (!(client instanceof Client)) {\n      throw new RxClientError('Client must be instance of Client class')\n    }\n\n    /**\n     * @type {Client}\n     * @private\n     */\n    this._client = client\n    /**\n     * @type {number}\n     * @private\n     */\n    this._txLevel = this._savedTxLevel = 0\n    /**\n     * @type {Observable}\n     * @private\n     */\n    this._errorSource = undefined\n    /**\n     * @type {Observable}\n     * @private\n     */\n    this._connectSource = undefined\n    /**\n     * @type {Observable}\n     * @private\n     */\n    this._endSource = undefined\n    /**\n     * @type {Observable}\n     * @private\n     */\n    this._querySource = undefined\n  }\n\n  /**\n   * Instance of `node-postgres` {@link Client} type.\n   *\n   * @type {Client}\n   */\n  get client () {\n    return this._client\n  }\n\n  /**\n   * Current transaction level.\n   *\n   * @type {number}\n   */\n  get txLevel () {\n    return this._txLevel\n  }\n\n  /**\n   * True if client connected.\n   *\n   * @type {boolean}\n   */\n  get connected () {\n    return this._client.connection.stream.readyState === 'open'\n  }\n\n  /**\n   * Errors hot observable. Use it to subscribe to the client error events.\n   *\n   * @see {@link Client}\n   *\n   * @type {Observable<Error>}\n   */\n  get errors () {\n    return this._errorSource\n  }\n\n  /**\n   * Cleanup client instance after closing connection.\n   *\n   * @private\n   */\n  _cleanup () {\n    util.log('RxClient: cleanup')\n\n    this._txLevel = this._savedTxLevel = 0\n    this._connectSource = undefined\n    this._endSource = undefined\n    this._querySource = undefined\n    this._errorSource = undefined\n  }\n\n  /**\n   * Opens connection to the database if it not already opened.\n   *\n   * @alias {@link RxClient#open}\n   *\n   * @example <caption>Connect to the database</caption>\n   * rxClient.connect()\n   *   .subscribe(\n   *     x => console.log('NEXT', 'Connection opened'),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE', 'Connection opened')\n   *   )\n   *\n   * @see {@link RxClient#end}\n   *\n   * @return {Observable<boolean>} Returns single boolean {@link Observable} sequence\n   *    multicasted with {@link ReplaySubject}\n   */\n  connect () {\n    if (!this._connectSource) {\n      this._connectSource = Observable.of(true)\n      // wrap errors with Observable to mixin it in external code\n      this._errorSource = Observable.fromEvent(this._client, 'error')\n\n      // subscribe to the end to make RxClient cleanup\n      Observable.fromEvent(this._client, 'end')\n        .take(1)\n        .subscribe({\n          error: ::this._cleanup,\n          complete: ::this._cleanup\n        })\n\n      if (!this.connected) {\n        const connect = Observable.bindNodeCallback(::this._client.connect, () => true)\n\n        this._connectSource = connect()\n          .do(() => util.log('RxClient: client connected'))\n          .publishReplay()\n          .refCount()\n      }\n    }\n    // todo ignore elements like in begin/commit/rollback ?\n    return this._connectSource\n  }\n\n  /**\n   * Alias of the {@link RxClient#connect}.\n   *\n   * @see {@link RxClient#connect}\n   *\n   * @return {Observable<boolean>} Returns single boolean {@link Observable} sequence\n   *    multicasted with {@link ReplaySubject}\n   */\n  open () {\n    return this.connect()\n  }\n\n  /**\n   * Closes connection to the database if client connected.\n   *\n   * @alias {@link RxClient#close}\n   *\n   * @example <caption>Close database connection</caption>\n   * rxClient.connect()\n   *   .concat(rxClient.end())\n   *   .subscribe(\n   *     x => console.log('NEXT', 'Connection closed'),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE', 'Connection closed')\n   *   )\n   *\n   * @see {@link RxClient#connect}\n   *\n   * @return {Observable<boolean>} Returns single boolean {@link Observable} sequence\n   *    multicasted with {@link ReplaySubject}\n   */\n  end () {\n    if (!this._endSource) {\n      this._endSource = Observable.of(true)\n\n      if (this._connectSource) {\n        const end = Observable.bindNodeCallback(::this._client.end, () => true)\n\n        this._endSource = this._connectSource.concatMap(() => end())\n          .do(() => util.log('RxClient: client ended'))\n          .publishReplay()\n          .refCount()\n      }\n    }\n\n    return this._endSource\n  }\n\n  /**\n   * Alias of the {@link RxClient#end}.\n   *\n   * @see {@link RxClient#end}\n   *\n   * @return {Observable<boolean>} Returns single boolean {@link Observable} sequence\n   *    multicasted with {@link ReplaySubject}\n   */\n  close () {\n    return this.end()\n  }\n\n  /**\n   * Executes SQL query with arguments and returns {@link Observable} sequence of the query {@link Result} object.\n   * You can pass result projection function as second or third argument to map {@link Result} object to\n   * another value that will be emitted by the result {@link Observable}.\n   * If client not yet connected then {@link RxClient#connect} will be called before query execution.\n   *\n   * @example <caption>Simple query with arguments</caption>\n   * rxClient.query('select * from main where id = $1', [ 1 ] )\n   *   .subscribe(\n   *     result => console.log('NEXT', result),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   * @example <caption>Map result to the first row</caption>\n   * rxClient.query(\n   *   'select * from main',\n   *   result => result.rows.slice().shift()\n   * ).subscribe(\n   *   firstRow => console.log('NEXT', firstRow),\n   *   err => console.error('ERROR', err.message),\n   *   () => console.log('COMPLETE', 'Query executed')\n   * )\n   * @example <caption>Flatten array of rows</caption>\n   * rxClient.query(\n   *   'select * from main',\n   *   result => Observable.from(result.rows.slice())\n   * ).subscribe(\n   *   row => console.log('NEXT', row),\n   *   err => console.error('ERROR', err.message),\n   *   () => console.log('COMPLETE', 'Query executed')\n   * )\n   *\n   * @see {@link RxClient#queryRow}\n   * @see {@link RxClient#queryRows}\n   * @see {@link RxClient#queryRowsFlat}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array|function(x: Result): *} [values] Array of query arguments or projection function.\n   * @param {function(x: Result): *} [projectFunction] A function which takes the query {@link Result}\n   *      and maps it ta the another value or inner {@link Observable}.\n   *\n   * @return {Observable} Returns {@link Observable} sequence of query {@link Result} or\n   *      whatever returned by the `projectFunction`.\n   */\n  query (queryText, values, projectFunction) {\n    if (isFunction(values)) {\n      projectFunction = values\n    }\n\n    this._querySource = (this._querySource || this.connect())\n      .concatMap(() => {\n        const query = Observable.bindNodeCallback(::this._client.query)\n\n        return query(queryText, values)\n      })\n      .do(\n        () => util.log('RxClient: query executed', queryText, this._txLevel),\n        () => {\n          this._restoreLevel()\n          this._querySource = undefined\n        }\n      )\n      .publishReplay()\n      .refCount()\n\n    let source = this._querySource\n    if (projectFunction) {\n      source = source.map(result => {\n        const projectedValue = projectFunction(result)\n\n        return projectedValue instanceof Observable\n          ? projectedValue\n          : Observable.of(projectedValue)\n      }).concatAll()\n    }\n\n    return source\n  }\n\n  /**\n   * Executes query and maps the query {@link Result} object to the first returned row.\n   *\n   * @see {@link RxClient#query}\n   * @see {@link RxClient#queryRows}\n   * @see {@link RxClient#queryRowsFlat}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} Single element {@link Observable} sequence of the first returned row.\n   */\n  queryRow (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice().shift())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to the array of rows.\n   *\n   * @see {@link RxClient#query}\n   * @see {@link RxClient#queryRow}\n   * @see {@link RxClient#queryRowsFlat}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Array<Object>>} {@link Observable} sequence of array of rows.\n   */\n  queryRows (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to {@link Observable} sequence of returned rows.\n   *\n   * @see {@link RxClient#query}\n   * @see {@link RxClient#queryRow}\n   * @see {@link RxClient#queryRows}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} {@link Observable} sequence of rows returned by the query.\n   */\n  queryRowsFlat (queryText, values) {\n    return this.query(queryText, values, result => Observable.from(result.rows.slice()))\n  }\n\n  /**\n   * Opens new transaction on the top level when {@link RxClient#txLevel} equals to 0,\n   * or creates savepoints for nested transactions when {@link RxClient#txLevel} more than 1 (i.e partial rollback).\n   * See PostgreSQL documentation for known limitations of savepoints.\n   *\n   * @example <caption>Execute SQL queries in transactions</caption>\n   * // RxClient#txLevel = 0\n   * // begin new transaction\n   * rxClient.begin() // RxClient#txLevel = 1\n   *   .concat(rxClient.queryRow(\n   *     'insert into main (name) values ($1) returning *',\n   *     [ 'qwerty' ]\n   *   ))\n   *   // work with inserted record\n   *   .mergeMap(\n   *     insertedRow => Observable.concat(\n   *       rxClient.begin(), // RxClient#txLevel = 2\n   *       // try to execute invalid query\n   *       rxClient.queryRow(\n   *         'update main set (id, name) = ($1, $2) where id = $3 returning *',\n   *         [ 1, 'qwerty new name', insertedRow.id ]\n   *       ),\n   *       rxClient.commit() // RxClient#txLevel = 1\n   *     ).catch(() => rxClient.rollback(insertedRow)) // rollback to the last savepoint if query failed\n   *   )\n   *   // commit the top level transaction\n   *   .mergeMap(row => rxClient.commit(row, true)) // RxClient#txLevel = 0\n   *   .subscribe(\n   *     row => console.log('NEXT', row),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#commit}\n   * @see {@link RxClient#rollback}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   *\n   * @return {Observable} Returns empty {@link Observable} sequence that completes\n   *      when transaction successfully opened or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @experimental\n   */\n  begin (mapTo) {\n    assert(this._txLevel >= 0, 'Current transaction level >= 0')\n\n    const begin = () => {\n      this._savedTxLevel = this._txLevel\n\n      let query\n      if (this._txLevel === 0) {\n        query = 'begin'\n      } else {\n        query = `savepoint point_${this._txLevel}`\n      }\n\n      ++this._txLevel\n\n      return this.query(query)\n    }\n\n    let source = begin()\n    if (mapTo != null) {\n      source = source.mapTo(mapTo)\n    } else {\n      source = source.ignoreElements()\n    }\n\n    return source\n  }\n\n  /**\n   * Commits current transaction when {@link RxClient#txLevel} equals to 1\n   * or releases last savepoint when {@link RxClient#txLevel} more that 1.\n   * Call with `force = true` commits current transaction with all savepoints\n   * from any depth level.\n   *\n   * @example <caption>Execute SQL queries in transactions</caption>\n   * // RxClient#txLevel = 0\n   * // begin new transaction\n   * rxClient.begin() // RxClient#txLevel = 1\n   *   .concat(rxClient.queryRow(\n   *     'insert into main (name) values ($1) returning *',\n   *     [ 'qwerty' ]\n   *   ))\n   *   // work with inserted record\n   *   .mergeMap(\n   *     insertedRow => Observable.concat(\n   *       rxClient.begin(), // RxClient#txLevel = 2\n   *       // try to execute invalid query\n   *       rxClient.queryRow(\n   *         'update main set (id, name) = ($1, $2) where id = $3 returning *',\n   *         [ 1, 'qwerty new name', insertedRow.id ]\n   *       ),\n   *       rxClient.commit() // RxClient#txLevel = 1\n   *     ).catch(() => rxClient.rollback(insertedRow)) // rollback to the last savepoint if query failed\n   *   )\n   *   // commit the top level transaction\n   *   .mergeMap(row => rxClient.commit(row, true)) // RxClient#txLevel = 0\n   *   .subscribe(\n   *     row => console.log('NEXT', row),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#begin}\n   * @see {@link RxClient#rollback}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   * @param {boolean} [force] If `true` commits transaction with all savepoints.\n   *\n   * @return {Observable} Returns empty {@link Observable} sequence that completes\n   *      when transaction successfully committed or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @throws {RxClientError} Throws when transaction doesn't exists.\n   *\n   * @experimental\n   */\n  commit (mapTo, force) {\n    assert(this._txLevel >= 0, 'Current transaction level >= 0')\n\n    const commit = () => {\n      if (this._txLevel === 0) {\n        throw new RxClientError('The transaction is not open on the client')\n      }\n\n      this._savedTxLevel = this._txLevel\n\n      let query\n      if (this._txLevel === 1 || force) {\n        query = 'commit'\n        this._txLevel = 0\n      } else {\n        query = `release savepoint point_${--this._txLevel}`\n      }\n\n      return this.query(query)\n    }\n\n    let source = commit()\n    if (mapTo) {\n      source = source.mapTo(mapTo)\n    } else {\n      source = source.ignoreElements()\n    }\n\n    return source\n  }\n\n  /**\n   * Rolls back current transaction when {@link RxClient#txLevel} equals to 1\n   * or rolls back to the last savepoint when {@link RxClient#txLevel} more that 1.\n   * Call with `force = true` rolls back current transaction with all savepoints\n   * from any depth level.\n   *\n   * @example <caption>Execute SQL queries in transactions</caption>\n   * // RxClient#txLevel = 0\n   * // begin new transaction\n   * rxClient.begin() // RxClient#txLevel = 1\n   *   .concat(rxClient.queryRow(\n   *     'insert into main (name) values ($1) returning *',\n   *     [ 'qwerty' ]\n   *   ))\n   *   // work with inserted record\n   *   .mergeMap(\n   *     insertedRow => Observable.concat(\n   *       rxClient.begin(), // RxClient#txLevel = 2\n   *       // try to execute invalid query\n   *       rxClient.queryRow(\n   *         'update main set (id, name) = ($1, $2) where id = $3 returning *',\n   *         [ 1, 'qwerty new name', insertedRow.id ]\n   *       ),\n   *       rxClient.commit() // RxClient#txLevel = 1\n   *     ).catch(() => rxClient.rollback(insertedRow)) // rollback to the last savepoint if query failed\n   *   )\n   *   // commit the top level transaction\n   *   .mergeMap(row => rxClient.commit(row, true)) // RxClient#txLevel = 0\n   *   .subscribe(\n   *     row => console.log('NEXT', row),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#begin}\n   * @see {@link RxClient#commit}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   * @param {boolean} [force] If `true` rolls back transaction with all savepoints.\n   *\n   * @return {Observable} Returns empty {@link Observable} sequence that completes\n   *      when transaction successfully rolled back or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @throws {RxClientError} Throws when transaction doesn't exists.\n   *\n   * @experimental\n   */\n  rollback (mapTo, force) {\n    assert(this._txLevel >= 0, 'Current transaction level >= 0')\n\n    const rollback = () => {\n      if (this._txLevel === 0) {\n        throw new RxClientError('The transaction is not opened on the client')\n      }\n\n      this._savedTxLevel = this._txLevel\n\n      let query\n      if (this._txLevel === 1 || force) {\n        query = 'rollback'\n        this._txLevel = 0\n      } else {\n        query = `rollback to savepoint point_${--this._txLevel}`\n      }\n\n      return this.query(query)\n    }\n\n    let source = rollback()\n    if (mapTo != null) {\n      source = source.mapTo(mapTo)\n    } else {\n      source = source.ignoreElements()\n    }\n\n    return source\n  }\n\n  _restoreLevel () {\n    if (this._savedTxLevel != null) {\n      this._txLevel = this._savedTxLevel\n    }\n  }\n}\n"]}