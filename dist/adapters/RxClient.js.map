{"version":3,"sources":["../../src/adapters/RxClient.js"],"names":["util","RxClient","client","_client","_txLevel","_savedTxLevel","log","source","of","connected","fromEvent","take","finally","_cleanup","subscribe","connect","bindNodeCallback","do","end","queryText","values","projectFunction","concatMap","query","_commitTxLevel","err","stack","_rollbackTxLevel","map","projectedValue","result","concatAll","rows","slice","shift","from","mapTo","begin","force","commit","rollback","func","catch","message","mergeMap","throw","connection","stream","readyState"],"mappings":"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","file":"RxClient.js","sourcesContent":["import assert from 'assert'\nimport { Client } from 'pg'\nimport { Observable } from 'rxjs'\nimport { RxClientError } from '../errors'\nimport * as util from '../util'\n\n/**\n * Standalone adapter for {@link Client} class with Reactive API.\n *\n * @example <caption>Basic usage</caption>\n * import { Client } from 'pg'\n * import { Observable } from 'rxjs'\n * import { RxClient } from 'rxjs-postgres'\n *\n * // Instantiate adapter with node-postgres Client instance\n * let rxClient = new RxClient(new Client({\n *   database: 'postgres',\n *   user: 'postgres'\n * }))\n *\n * // get multiple records from the database (connection will be opened automatically on the first query call)\n * rxClient.queryRowsSeq('select * from main'))\n *   .subscribe(\n *     row => console.log('NEXT', row),\n *     err => console.error('ERROR', err.stack),\n *     () => console.log('COMPLETE')\n *   )\n *\n * @see {@link RxPool}\n * @see {@link Client}\n *\n * @todo helpers for column value selection\n */\nexport default class RxClient {\n  /**\n   * Creates new RxClient instance.\n   *\n   * @example <caption>Initialization</caption>\n   * import { Client } from 'pg'\n   * import { RxClient } from 'rxjs-postgres'\n   *\n   * const rxClient = new RxClient(new Client())\n   * // now you are ready to work with PostgreSQL\n   * // load some record\n   * rxClient.queryRow('select * from main where id = $1', [ 1 ])\n   *   // then load some additional related records\n   *   .mergeMap(\n   *     mainRow => rxClient.queryRows(\n   *       'select * from child where main_id = $1',\n   *       [ mainRow.id ]\n   *     ),\n   *     (mainRow, children) => ({ ...mainRow, children })\n   *   )\n   *   .subscribe(\n   *     mainRow => console.log('NEXT', mainRow),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#connect}\n   * @see {@link RxClient#end}\n   * @see {@link RxClient#query}\n   *\n   * @param {Client} client Instance of {@link Client}.\n   *\n   * @throws {RxClientError} Throws when called with invalid arguments.\n   * @throws {TypeError} Throws when called as function.\n   */\n  constructor (client) {\n    if (!(client instanceof Client)) {\n      throw new RxClientError('Client must be instance of Client class')\n    }\n\n    /**\n     * @type {Client}\n     * @private\n     */\n    this._client = client\n    /**\n     * @type {number}\n     * @private\n     */\n    this._txLevel = this._savedTxLevel = 0\n  }\n\n  /**\n   * Instance of {@link Client}.\n   *\n   * @type {Client}\n   */\n  get client () {\n    return this._client\n  }\n\n  /**\n   * Current transaction level.\n   *\n   * @type {number}\n   */\n  get txLevel () {\n    return this._txLevel\n  }\n\n  /**\n   * True if client connected.\n   *\n   * @type {boolean}\n   */\n  get connected () {\n    return this._client.connection.stream.readyState === 'open'\n  }\n\n  /**\n   * Cleanup client instance after closing connection.\n   *\n   * @private\n   */\n  _cleanup () {\n    util.log('RxClient: cleanup')\n\n    this._txLevel = this._savedTxLevel = 0\n  }\n\n  /**\n   * Opens connection to the database if it not already opened.\n   *\n   * @alias {@link RxClient#open}\n   *\n   * @example <caption>Connect to the database</caption>\n   * rxClient.connect()\n   *   .subscribe(\n   *     x => console.log('NEXT', 'Connection opened'),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE', 'Connection opened')\n   *   )\n   *\n   * @see {@link RxClient#end}\n   *\n   * @return {Observable<boolean>} Returns single element {@link Observable} sequence.\n   */\n  connect () {\n    let source = Observable.of(true)\n\n    if (!this.connected) {\n      // subscribe to the end to make RxClient cleanup\n      // noinspection JSUnresolvedFunction\n      Observable.fromEvent(this._client, 'end')\n        .take(1)\n        .finally(::this._cleanup)\n        .subscribe()\n\n      const connect = Observable.bindNodeCallback(::this._client.connect, () => true)\n      source = connect().do(() => util.log('RxClient: client connected'))\n    }\n\n    return source\n  }\n\n  /**\n   * Alias of the {@link RxClient#connect}.\n   *\n   * @see {@link RxClient#connect}\n   *\n   * @return {Observable<boolean>} Returns single element {@link Observable} sequence.\n   */\n  open () {\n    return this.connect()\n  }\n\n  /**\n   * Closes connection to the database if client connected.\n   *\n   * @alias {@link RxClient#close}\n   *\n   * @example <caption>Close database connection</caption>\n   * rxClient.connect()\n   *   .concatMap(() => rxClient.end())\n   *   .subscribe(\n   *     x => console.log('NEXT', 'Connection closed'),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE', 'Connection closed')\n   *   )\n   *\n   * @see {@link RxClient#connect}\n   *\n   * @return {Observable<boolean>} Returns single element {@link Observable} sequence.\n   */\n  end () {\n    let source = Observable.of(true)\n\n    if (this.connected) {\n      const end = Observable.bindNodeCallback(::this._client.end, () => true)\n      source = end().do(() => util.log('RxClient: client ended'))\n    }\n\n    return source\n  }\n\n  /**\n   * Alias of the {@link RxClient#end}.\n   *\n   * @see {@link RxClient#end}\n   *\n   * @return {Observable<boolean>} Returns single boolean {@link Observable} sequence\n   */\n  close () {\n    return this.end()\n  }\n\n  /**\n   * Executes SQL query with arguments and returns {@link Observable} sequence of the query {@link Result} object.\n   * You can pass result projection function as second or third argument to map {@link Result} object to\n   * another value that will be emitted by the outer {@link Observable}.\n   * If client not yet connected then {@link RxClient#connect} will be called before query execution.\n   *\n   * @example <caption>Simple query with arguments</caption>\n   * rxClient.query('select * from main where id = $1', [ 1 ])\n   *   .subscribe(\n   *     result => console.log('NEXT', result),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   * @example <caption>Query with arguments and result projection function</caption>\n   * rxClient.query(\n   *   'select * from main where id = $1',\n   *   [ 123 ],\n   *   result => result.rows.slice().shift()\n   * ).subscribe(\n   *   firstRow => console.log('NEXT', firstRow),\n   *   err => console.error('ERROR', err.message),\n   *   () => console.log('COMPLETE', 'Query executed')\n   * )\n   *\n   * @see {@link RxClient#queryRow}\n   * @see {@link RxClient#queryRows}\n   * @see {@link RxClient#queryRowsSeq}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array|function(x: Result): *} [values] Array of query arguments or projection function.\n   * @param {function(x: Result): *} [projectFunction] A function which takes the query {@link Result}\n   *      and maps it ta the another value or inner {@link Observable}.\n   *\n   * @return {Observable<T>} Returns {@link Observable} sequence of query {@link Result} or\n   *      whatever returned by the `projectFunction`.\n   */\n  query (queryText, values, projectFunction) {\n    if (typeof values === 'function') {\n      projectFunction = values\n    }\n\n    let source = this.connect()\n      .concatMap(() => {\n        const query = Observable.bindNodeCallback(::this._client.query)\n\n        return query(queryText, values)\n      })\n      .do(\n        () => {\n          util.log('RxClient: query executed', [ queryText, this._txLevel ])\n          this._commitTxLevel()\n        },\n        err => {\n          util.err(`RxClient: query failed`, [ queryText, this._txLevel, err.stack ])\n          this._rollbackTxLevel()\n        }\n      )\n\n    if (projectFunction) {\n      source = source.map(result => {\n        const projectedValue = projectFunction(result)\n\n        return projectedValue instanceof Observable\n          ? projectedValue\n          : Observable.of(projectedValue)\n      }).concatAll()\n    }\n\n    return source\n  }\n\n  /**\n   * Executes query and maps the query {@link Result} object to the first returned row.\n   *\n   * @see {@link RxClient#query}\n   * @see {@link RxClient#queryRows}\n   * @see {@link RxClient#queryRowsSeq}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} Single element {@link Observable} sequence of the first returned row.\n   */\n  queryRow (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice().shift())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to the array of rows.\n   *\n   * @see {@link RxClient#query}\n   * @see {@link RxClient#queryRow}\n   * @see {@link RxClient#queryRowsSeq}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Array<Object>>} {@link Observable} sequence of array of rows.\n   */\n  queryRows (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to {@link Observable} sequence of returned rows.\n   *\n   * @see {@link RxClient#query}\n   * @see {@link RxClient#queryRow}\n   * @see {@link RxClient#queryRows}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} {@link Observable} sequence of rows returned by the query.\n   */\n  queryRowsSeq (queryText, values) {\n    return this.query(queryText, values, result => Observable.from(result.rows.slice()))\n  }\n\n  /**\n   * Opens new transaction on the top level when {@link RxClient#txLevel} equals to 0,\n   * or creates savepoints for nested transactions when {@link RxClient#txLevel} more than 1 (i.e partial rollback).\n   * See PostgreSQL documentation for known limitations of savepoints.\n   *\n   * @example <caption>Execute SQL queries in transactions</caption>\n   * // RxClient#txLevel = 0\n   * // begin new transaction\n   * rxClient.begin() // RxClient#txLevel = 1\n   *   .mergeMap(() => rxClient.queryRow(\n   *     'insert into main (name) values ($1) returning *',\n   *     [ 'qwerty' ]\n   *   ))\n   *   // work with inserted record\n   *   .mergeMap(\n   *     insertedRow => rxClient.begin() // RxClient#txLevel = 2\n   *       // try to execute invalid query\n   *       .mergeMap(() => rxClient.queryRow(\n   *         'update main set (id, name) = ($1, $2) where id = $3 returning *',\n   *         [ 1, 'qwerty new name', insertedRow.id ]\n   *       ))\n   *       .mergeMap(updatedRow => rxClient.commit(updatedRow)) // RxClient#txLevel = 1\n   *       .catch(() => rxClient.rollback(insertedRow))  // rollback to the last savepoint if query failed\n   *   )\n   *   // commit the top level transaction\n   *   .mergeMap(row => rxClient.commit(row, true)) // RxClient#txLevel = 0\n   *   .subscribe(\n   *     row => console.log('NEXT', row),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#commit}\n   * @see {@link RxClient#rollback}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   *\n   * @return {Observable} Returns single element {@link Observable} sequence that completes\n   *      when transaction successfully opened or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @experimental\n   */\n  begin (mapTo = true) {\n    assert(this._txLevel >= 0, 'Current transaction level >= 0')\n\n    const begin = () => {\n      this._commitTxLevel()\n\n      let query\n      if (this._txLevel === 0) {\n        query = 'begin'\n      } else {\n        query = `savepoint point_${this._txLevel}`\n      }\n\n      ++this._txLevel\n\n      return this.query(query)\n    }\n\n    return begin().mapTo(mapTo)\n  }\n\n  /**\n   * Commits current transaction when {@link RxClient#txLevel} equals to 1\n   * or releases last savepoint when {@link RxClient#txLevel} more that 1.\n   * Call with `force = true` commits current transaction with all savepoints\n   * from any depth level.\n   *\n   * @example <caption>Execute SQL queries in transactions</caption>\n   * // RxClient#txLevel = 0\n   * // begin new transaction\n   * rxClient.begin() // RxClient#txLevel = 1\n   *   .mergeMap(() => rxClient.queryRow(\n   *     'insert into main (name) values ($1) returning *',\n   *     [ 'qwerty' ]\n   *   ))\n   *   // work with inserted record\n   *   .mergeMap(\n   *     insertedRow => rxClient.begin() // RxClient#txLevel = 2\n   *       // try to execute invalid query\n   *       .mergeMap(() => rxClient.queryRow(\n   *         'update main set (id, name) = ($1, $2) where id = $3 returning *',\n   *         [ 1, 'qwerty new name', insertedRow.id ]\n   *       ))\n   *       .mergeMap(updatedRow => rxClient.commit(updatedRow)) // RxClient#txLevel = 1\n   *       .catch(() => rxClient.rollback(insertedRow))  // rollback to the last savepoint if query failed\n   *   )\n   *   // commit the top level transaction\n   *   .mergeMap(row => rxClient.commit(row, true)) // RxClient#txLevel = 0\n   *   .subscribe(\n   *     row => console.log('NEXT', row),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#begin}\n   * @see {@link RxClient#rollback}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   * @param {boolean} [force] If `true` commits transaction with all savepoints.\n   *\n   * @return {Observable} Returns single element {@link Observable} sequence that completes\n   *      when transaction successfully committed or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @throws {RxClientError} Throws when transaction doesn't exists.\n   *\n   * @experimental\n   */\n  commit (mapTo = true, force = false) {\n    assert(this._txLevel >= 0, 'Current transaction level >= 0')\n\n    const commit = () => {\n      if (this._txLevel === 0) {\n        throw new RxClientError('The transaction is not opened on the client')\n      }\n\n      this._commitTxLevel()\n\n      let query\n      if (this._txLevel === 1 || force) {\n        query = 'commit'\n        this._txLevel = 0\n      } else {\n        query = `release savepoint point_${--this._txLevel}`\n      }\n\n      return this.query(query)\n    }\n\n    return commit().mapTo(mapTo)\n  }\n\n  /**\n   * Rolls back current transaction when {@link RxClient#txLevel} equals to 1\n   * or rolls back to the last savepoint when {@link RxClient#txLevel} more that 1.\n   * Call with `force = true` rolls back current transaction with all savepoints\n   * from any depth level.\n   *\n   * @example <caption>Execute SQL queries in transactions</caption>\n   * // RxClient#txLevel = 0\n   * // begin new transaction\n   * rxClient.begin() // RxClient#txLevel = 1\n   *   .mergeMap(() => rxClient.queryRow(\n   *     'insert into main (name) values ($1) returning *',\n   *     [ 'qwerty' ]\n   *   ))\n   *   // work with inserted record\n   *   .mergeMap(\n   *     insertedRow => rxClient.begin() // RxClient#txLevel = 2\n   *       // try to execute invalid query\n   *       .mergeMap(() => rxClient.queryRow(\n   *         'update main set (id, name) = ($1, $2) where id = $3 returning *',\n   *         [ 1, 'qwerty new name', insertedRow.id ]\n   *       ))\n   *       .mergeMap(updatedRow => rxClient.commit(updatedRow)) // RxClient#txLevel = 1\n   *       .catch(() => rxClient.rollback(insertedRow))  // rollback to the last savepoint if query failed\n   *   )\n   *   // commit the top level transaction\n   *   .mergeMap(row => rxClient.commit(row, true)) // RxClient#txLevel = 0\n   *   .subscribe(\n   *     row => console.log('NEXT', row),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#begin}\n   * @see {@link RxClient#commit}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   * @param {boolean} [force] If `true` rolls back transaction with all savepoints.\n   *\n   * @return {Observable} Returns single element {@link Observable} sequence that completes\n   *      when transaction successfully rolled back or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @throws {RxClientError} Throws when transaction doesn't exists.\n   *\n   * @experimental\n   */\n  rollback (mapTo = true, force = true) {\n    assert(this._txLevel >= 0, 'Current transaction level >= 0')\n\n    const rollback = () => {\n      if (this._txLevel === 0) {\n        throw new RxClientError('The transaction is not opened on the client')\n      }\n\n      this._commitTxLevel()\n\n      let query\n      if (this._txLevel === 1 || force) {\n        query = 'rollback'\n        this._txLevel = 0\n      } else {\n        query = `rollback to savepoint point_${--this._txLevel}`\n      }\n\n      return this.query(query)\n    }\n\n    return rollback().mapTo(mapTo)\n  }\n\n  /**\n   * @param {function(): Observable} func\n   * @return {Observable<T>}\n   */\n  tx (func) {\n    return this.begin()\n      .concatMap(() => func())\n      .concatMap(result => this.commit(result))\n      .catch(err => {\n        util.err(err.message, [ err.stack ])\n\n        return this.rollback()\n          .mergeMap(() => Observable.throw(err))\n      })\n  }\n\n  /**\n   * @private\n   */\n  _commitTxLevel () {\n    this._savedTxLevel = this._txLevel\n  }\n\n  /**\n   * @private\n   */\n  _rollbackTxLevel () {\n    this._txLevel = this._savedTxLevel\n  }\n}\n"]}