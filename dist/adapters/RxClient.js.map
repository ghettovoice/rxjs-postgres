{"version":3,"sources":["../../src/adapters/RxClient.js"],"names":["util","RxClient","client","_client","_txLevel","_savedTxLevel","_errorSource","fromEvent","_connectSource","undefined","_endSource","_querySource","log","of","take","finally","_cleanup","subscribe","connected","connect","bindNodeCallback","do","publishReplay","refCount","end","concatMap","queryText","values","projectFunction","query","_commitTxLevel","err","_rollbackTxLevel","source","map","projectedValue","result","concatAll","rows","slice","shift","from","mapTo","begin","ignoreElements","force","commit","rollback","connection","stream","readyState"],"mappings":";;;;;;;;AAAA;;;;AACA;;AACA;;AACA;;AACA;;IAAYA,I;;;;;;;;AAEZ;;;;;;;;;;;;;;;;;;;;;;;;;;;IA2BqBC,Q;AACnB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,oBAAaC,MAAb,EAAqB;AAAA;;AACnB,QAAI,EAAEA,4BAAF,CAAJ,EAAiC;AAC/B,YAAM,0BAAkB,yCAAlB,CAAN;AACD;;AAED;;;;AAIA,SAAKC,OAAL,GAAeD,MAAf;AACA;;;;AAIA,SAAKE,QAAL,GAAgB,KAAKC,aAAL,GAAqB,CAArC;AACA;;;;AAIA,SAAKC,YAAL,GAAoB,iBAAWC,SAAX,CAAqB,KAAKJ,OAA1B,EAAmC,OAAnC,CAApB;AACA;;;;AAIA,SAAKK,cAAL,GAAsBC,SAAtB;AACA;;;;AAIA,SAAKC,UAAL,GAAkBD,SAAlB;AACA;;;;AAIA,SAAKE,YAAL,GAAoBF,SAApB;AACD;;AAED;;;;;;;;;;;AAsCA;;;;;+BAKY;AACVT,WAAKY,GAAL,CAAS,mBAAT;;AAEA,WAAKR,QAAL,GAAgB,KAAKC,aAAL,GAAqB,CAArC;AACA,WAAKG,cAAL,GAAsBC,SAAtB;AACA,WAAKC,UAAL,GAAkBD,SAAlB;AACA,WAAKE,YAAL,GAAoBF,SAApB;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;8BAkBW;AACT,UAAI,CAAC,KAAKD,cAAV,EAA0B;AACxB,aAAKA,cAAL,GAAsB,iBAAWK,EAAX,CAAc,IAAd,CAAtB;AACA;AACA,yBAAWN,SAAX,CAAqB,KAAKJ,OAA1B,EAAmC,KAAnC,EACGW,IADH,CACQ,CADR,EAEGC,OAFH,CAEa,KAAKC,QAFlB,MAEa,IAFb,GAGGC,SAHH;;AAKA,YAAI,CAAC,KAAKC,SAAV,EAAqB;AAAA;;AACnB,cAAMC,UAAU,iBAAWC,gBAAX,CAA8B,iBAAKjB,OAAL,EAAagB,OAA3C,iBAAoD;AAAA,mBAAM,IAAN;AAAA,WAApD,CAAhB;;AAEA,eAAKX,cAAL,GAAsBW,UACnBE,EADmB,CAChB;AAAA,mBAAMrB,KAAKY,GAAL,CAAS,4BAAT,CAAN;AAAA,WADgB,EAEnBU,aAFmB,GAGnBC,QAHmB,EAAtB;AAID;AACF;;AAED,aAAO,KAAKf,cAAZ;AACD;;AAED;;;;;;;;;;;2BAQQ;AACN,aAAO,KAAKW,OAAL,EAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;0BAmBO;AAAA;;AACL,UAAI,CAAC,KAAKT,UAAV,EAAsB;AACpB,aAAKA,UAAL,GAAkB,iBAAWG,EAAX,CAAc,IAAd,CAAlB;;AAEA,YAAI,KAAKL,cAAT,EAAyB;AAAA;AAAA;;AACvB,gBAAMgB,MAAM,iBAAWJ,gBAAX,CAA8B,mBAAKjB,OAAL,EAAaqB,GAA3C,kBAAgD;AAAA,qBAAM,IAAN;AAAA,aAAhD,CAAZ;;AAEA,kBAAKd,UAAL,GAAkB,MAAKF,cAAL,CAAoBiB,SAApB,CAA8B;AAAA,qBAAMD,KAAN;AAAA,aAA9B,EACfH,EADe,CACZ;AAAA,qBAAMrB,KAAKY,GAAL,CAAS,wBAAT,CAAN;AAAA,aADY,EAEfU,aAFe,GAGfC,QAHe,EAAlB;AAHuB;AAOxB;AACF;;AAED,aAAO,KAAKb,UAAZ;AACD;;AAED;;;;;;;;;;;4BAQS;AACP,aAAO,KAAKc,GAAL,EAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BA4COE,S,EAAWC,M,EAAQC,e,EAAiB;AAAA;;AACzC,UAAI,OAAOD,MAAP,KAAkB,UAAtB,EAAkC;AAChCC,0BAAkBD,MAAlB;AACD;;AAED,WAAKhB,YAAL,GAAoB,CAAC,KAAKA,YAAL,IAAqB,KAAKQ,OAAL,EAAtB,EACjBM,SADiB,CACP,YAAM;AAAA;;AACf,YAAMI,QAAQ,iBAAWT,gBAAX,CAA8B,oBAAKjB,OAAL,EAAa0B,KAA3C,iBAAd;;AAEA,eAAOA,MAAMH,SAAN,EAAiBC,MAAjB,CAAP;AACD,OALiB,EAMjBN,EANiB,CAOhB,YAAM;AACJrB,aAAKY,GAAL,CAAS,0BAAT,EAAqC,CAAEc,SAAF,EAAa,OAAKtB,QAAlB,CAArC;AACA,eAAK0B,cAAL;AACD,OAVe,EAWhB,YAAM;AACJ9B,aAAK+B,GAAL,CAAS,0BAAT,EAAqC,CAAEL,SAAF,EAAa,OAAKtB,QAAlB,CAArC;AACA,eAAK4B,gBAAL;AACA,eAAKrB,YAAL,GAAoBF,SAApB;AACD,OAfe,EAiBjBa,aAjBiB,GAkBjBC,QAlBiB,EAApB;;AAoBA,UAAIU,SAAS,KAAKtB,YAAlB;AACA,UAAIiB,eAAJ,EAAqB;AACnBK,iBAASA,OAAOC,GAAP,CAAW,kBAAU;AAC5B,cAAMC,iBAAiBP,gBAAgBQ,MAAhB,CAAvB;;AAEA,iBAAOD,6CACHA,cADG,GAEH,iBAAWtB,EAAX,CAAcsB,cAAd,CAFJ;AAGD,SANQ,EAMNE,SANM,EAAT;AAOD;;AAED,aAAOJ,MAAP;AACD;;AAED;;;;;;;;;;;;;;;6BAYUP,S,EAAWC,M,EAAQ;AAC3B,aAAO,KAAKE,KAAL,CAAWH,SAAX,EAAsBC,MAAtB,EAA8B;AAAA,eAAUS,OAAOE,IAAP,CAAYC,KAAZ,GAAoBC,KAApB,EAAV;AAAA,OAA9B,CAAP;AACD;;AAED;;;;;;;;;;;;;;;8BAYWd,S,EAAWC,M,EAAQ;AAC5B,aAAO,KAAKE,KAAL,CAAWH,SAAX,EAAsBC,MAAtB,EAA8B;AAAA,eAAUS,OAAOE,IAAP,CAAYC,KAAZ,EAAV;AAAA,OAA9B,CAAP;AACD;;AAED;;;;;;;;;;;;;;;iCAYcb,S,EAAWC,M,EAAQ;AAC/B,aAAO,KAAKE,KAAL,CAAWH,SAAX,EAAsBC,MAAtB,EAA8B;AAAA,eAAU,iBAAWc,IAAX,CAAgBL,OAAOE,IAAP,CAAYC,KAAZ,EAAhB,CAAV;AAAA,OAA9B,CAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BA8COG,K,EAAO;AAAA;;AACZ,4BAAO,KAAKtC,QAAL,IAAiB,CAAxB,EAA2B,gCAA3B;;AAEA,UAAMuC,QAAQ,SAARA,KAAQ,GAAM;AAClB,eAAKb,cAAL;;AAEA,YAAID,cAAJ;AACA,YAAI,OAAKzB,QAAL,KAAkB,CAAtB,EAAyB;AACvByB,kBAAQ,OAAR;AACD,SAFD,MAEO;AACLA,uCAA2B,OAAKzB,QAAhC;AACD;;AAED,UAAE,OAAKA,QAAP;;AAEA,eAAO,OAAKyB,KAAL,CAAWA,KAAX,CAAP;AACD,OAbD;;AAeA,UAAII,SAASU,OAAb;AACA,UAAID,SAAS,IAAb,EAAmB;AACjBT,iBAASA,OAAOS,KAAP,CAAaA,KAAb,CAAT;AACD,OAFD,MAEO;AACLT,iBAASA,OAAOW,cAAP,EAAT;AACD;;AAED,aAAOX,MAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BAkDQS,K,EAAOG,K,EAAO;AAAA;;AACpB,4BAAO,KAAKzC,QAAL,IAAiB,CAAxB,EAA2B,gCAA3B;;AAEA,UAAM0C,SAAS,SAATA,MAAS,GAAM;AACnB,YAAI,OAAK1C,QAAL,KAAkB,CAAtB,EAAyB;AACvB,gBAAM,0BAAkB,6CAAlB,CAAN;AACD;;AAED,eAAK0B,cAAL;;AAEA,YAAID,cAAJ;AACA,YAAI,OAAKzB,QAAL,KAAkB,CAAlB,IAAuByC,KAA3B,EAAkC;AAChChB,kBAAQ,QAAR;AACA,iBAAKzB,QAAL,GAAgB,CAAhB;AACD,SAHD,MAGO;AACLyB,+CAAmC,EAAE,OAAKzB,QAA1C;AACD;;AAED,eAAO,OAAKyB,KAAL,CAAWA,KAAX,CAAP;AACD,OAhBD;;AAkBA,UAAII,SAASa,QAAb;AACA,UAAIJ,SAAS,IAAb,EAAmB;AACjBT,iBAASA,OAAOS,KAAP,CAAaA,KAAb,CAAT;AACD,OAFD,MAEO;AACLT,iBAASA,OAAOW,cAAP,EAAT;AACD;;AAED,aAAOX,MAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAkDUS,K,EAAOG,K,EAAO;AAAA;;AACtB,4BAAO,KAAKzC,QAAL,IAAiB,CAAxB,EAA2B,gCAA3B;;AAEA,UAAM2C,WAAW,SAAXA,QAAW,GAAM;AACrB,YAAI,OAAK3C,QAAL,KAAkB,CAAtB,EAAyB;AACvB,gBAAM,0BAAkB,6CAAlB,CAAN;AACD;;AAED,eAAK0B,cAAL;;AAEA,YAAID,cAAJ;AACA,YAAI,OAAKzB,QAAL,KAAkB,CAAlB,IAAuByC,KAA3B,EAAkC;AAChChB,kBAAQ,UAAR;AACA,iBAAKzB,QAAL,GAAgB,CAAhB;AACD,SAHD,MAGO;AACLyB,mDAAuC,EAAE,OAAKzB,QAA9C;AACD;;AAED,eAAO,OAAKyB,KAAL,CAAWA,KAAX,CAAP;AACD,OAhBD;;AAkBA,UAAII,SAASc,UAAb;AACA,UAAIL,SAAS,IAAb,EAAmB;AACjBT,iBAASA,OAAOS,KAAP,CAAaA,KAAb,CAAT;AACD,OAFD,MAEO;AACLT,iBAASA,OAAOW,cAAP,EAAT;AACD;;AAED,aAAOX,MAAP;AACD;;AAED;;;;;;qCAGkB;AAChB,WAAK5B,aAAL,GAAqB,KAAKD,QAA1B;AACD;;AAED;;;;;;uCAGoB;AAClB,WAAKA,QAAL,GAAgB,KAAKC,aAArB;AACD;;;wBA9gBa;AACZ,aAAO,KAAKF,OAAZ;AACD;;AAED;;;;;;;;wBAKe;AACb,aAAO,KAAKC,QAAZ;AACD;;AAED;;;;;;;;wBAKiB;AACf,aAAO,KAAKD,OAAL,CAAa6C,UAAb,CAAwBC,MAAxB,CAA+BC,UAA/B,KAA8C,MAArD;AACD;;AAED;;;;;;;;;;wBAOc;AACZ,aAAO,KAAK5C,YAAZ;AACD;;;;;;kBA5GkBL,Q","file":"RxClient.js","sourcesContent":["import assert from 'assert'\nimport { Client } from 'pg'\nimport { Observable } from 'rxjs'\nimport { RxClientError } from '../errors'\nimport * as util from '../util'\n\n/**\n * Standalone adapter for {@link Client} class with Reactive API.\n *\n * @example <caption>Basic usage</caption>\n * import { Client } from 'pg'\n * import { Observable } from 'rxjs'\n * import { RxClient } from 'rxjs-postgres'\n *\n * // Instantiate adapter with node-postgres Client instance\n * let rxClient = new RxClient(new Client({\n *   database: 'postgres',\n *   user: 'postgres'\n * }))\n *\n * // get multiple records from the database (connection will be opened automatically on the first query call)\n * rxClient.queryRowsSeq('select * from main'))\n *   .subscribe(\n *     row => console.log('NEXT', row),\n *     err => console.error('ERROR', err.stack),\n *     () => console.log('COMPLETE')\n *   )\n *\n * @see {@link RxPool}\n * @see {@link Client}\n *\n * @todo helpers for column value selection\n */\nexport default class RxClient {\n  /**\n   * Creates new RxClient instance.\n   *\n   * @example <caption>Initialization</caption>\n   * import { Client } from 'pg'\n   * import { RxClient } from 'rxjs-postgres'\n   *\n   * const rxClient = new RxClient(new Client())\n   * // now you are ready to work with PostgreSQL\n   * // load some record\n   * rxClient.queryRow('select * from main where id = $1', [ 1 ])\n   *   // then load some additional related records\n   *   .flatMap(\n   *     mainRow => rxClient.queryRows(\n   *       'select * from child where main_id = $1',\n   *       [ mainRow.id ]\n   *     ),\n   *     (mainRow, children) => ({ ...mainRow, children })\n   *   )\n   *   .subscribe(\n   *     mainRow => console.log('NEXT', mainRow),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#connect}\n   * @see {@link RxClient#end}\n   * @see {@link RxClient#query}\n   *\n   * @param {Client} client Instance of {@link Client}.\n   *\n   * @throws {RxClientError} Throws when called with invalid arguments.\n   * @throws {TypeError} Throws when called as function.\n   */\n  constructor (client) {\n    if (!(client instanceof Client)) {\n      throw new RxClientError('Client must be instance of Client class')\n    }\n\n    /**\n     * @type {Client}\n     * @private\n     */\n    this._client = client\n    /**\n     * @type {number}\n     * @private\n     */\n    this._txLevel = this._savedTxLevel = 0\n    /**\n     * @type {Observable}\n     * @private\n     */\n    this._errorSource = Observable.fromEvent(this._client, 'error')\n    /**\n     * @type {Observable}\n     * @private\n     */\n    this._connectSource = undefined\n    /**\n     * @type {Observable}\n     * @private\n     */\n    this._endSource = undefined\n    /**\n     * @type {Observable}\n     * @private\n     */\n    this._querySource = undefined\n  }\n\n  /**\n   * Instance of {@link Client}.\n   *\n   * @type {Client}\n   */\n  get client () {\n    return this._client\n  }\n\n  /**\n   * Current transaction level.\n   *\n   * @type {number}\n   */\n  get txLevel () {\n    return this._txLevel\n  }\n\n  /**\n   * True if client connected.\n   *\n   * @type {boolean}\n   */\n  get connected () {\n    return this._client.connection.stream.readyState === 'open'\n  }\n\n  /**\n   * Errors hot observable. Use it to subscribe to the client error events.\n   *\n   * @see {@link Client}\n   *\n   * @type {Observable<Error>}\n   */\n  get errors () {\n    return this._errorSource\n  }\n\n  /**\n   * Cleanup client instance after closing connection.\n   *\n   * @private\n   */\n  _cleanup () {\n    util.log('RxClient: cleanup')\n\n    this._txLevel = this._savedTxLevel = 0\n    this._connectSource = undefined\n    this._endSource = undefined\n    this._querySource = undefined\n  }\n\n  /**\n   * Opens connection to the database if it not already opened.\n   *\n   * @alias {@link RxClient#open}\n   *\n   * @example <caption>Connect to the database</caption>\n   * rxClient.connect()\n   *   .subscribe(\n   *     x => console.log('NEXT', 'Connection opened'),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE', 'Connection opened')\n   *   )\n   *\n   * @see {@link RxClient#end}\n   *\n   * @return {Observable<boolean>} Returns single boolean {@link Observable} sequence\n   *    multicasted with {@link ReplaySubject}\n   */\n  connect () {\n    if (!this._connectSource) {\n      this._connectSource = Observable.of(true)\n      // subscribe to the end to make RxClient cleanup\n      Observable.fromEvent(this._client, 'end')\n        .take(1)\n        .finally(::this._cleanup)\n        .subscribe()\n\n      if (!this.connected) {\n        const connect = Observable.bindNodeCallback(::this._client.connect, () => true)\n\n        this._connectSource = connect()\n          .do(() => util.log('RxClient: client connected'))\n          .publishReplay()\n          .refCount()\n      }\n    }\n\n    return this._connectSource\n  }\n\n  /**\n   * Alias of the {@link RxClient#connect}.\n   *\n   * @see {@link RxClient#connect}\n   *\n   * @return {Observable<boolean>} Returns single boolean {@link Observable} sequence\n   *    multicasted with {@link ReplaySubject}\n   */\n  open () {\n    return this.connect()\n  }\n\n  /**\n   * Closes connection to the database if client connected.\n   *\n   * @alias {@link RxClient#close}\n   *\n   * @example <caption>Close database connection</caption>\n   * rxClient.connect()\n   *   .concat(rxClient.end())\n   *   .subscribe(\n   *     x => console.log('NEXT', 'Connection closed'),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE', 'Connection closed')\n   *   )\n   *\n   * @see {@link RxClient#connect}\n   *\n   * @return {Observable<boolean>} Returns single boolean {@link Observable} sequence\n   *    multicasted with {@link ReplaySubject}\n   */\n  end () {\n    if (!this._endSource) {\n      this._endSource = Observable.of(true)\n\n      if (this._connectSource) {\n        const end = Observable.bindNodeCallback(::this._client.end, () => true)\n\n        this._endSource = this._connectSource.concatMap(() => end())\n          .do(() => util.log('RxClient: client ended'))\n          .publishReplay()\n          .refCount()\n      }\n    }\n\n    return this._endSource\n  }\n\n  /**\n   * Alias of the {@link RxClient#end}.\n   *\n   * @see {@link RxClient#end}\n   *\n   * @return {Observable<boolean>} Returns single boolean {@link Observable} sequence\n   *    multicasted with {@link ReplaySubject}\n   */\n  close () {\n    return this.end()\n  }\n\n  /**\n   * Executes SQL query with arguments and returns {@link Observable} sequence of the query {@link Result} object.\n   * You can pass result projection function as second or third argument to map {@link Result} object to\n   * another value that will be emitted by the result {@link Observable}.\n   * If client not yet connected then {@link RxClient#connect} will be called before query execution.\n   *\n   * @example <caption>Simple query with arguments</caption>\n   * rxClient.query('select * from main where id = $1', [ 1 ] )\n   *   .subscribe(\n   *     result => console.log('NEXT', result),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   * @example <caption>Map result to the first row</caption>\n   * rxClient.query(\n   *   'select * from main',\n   *   result => result.rows.slice().shift()\n   * ).subscribe(\n   *   firstRow => console.log('NEXT', firstRow),\n   *   err => console.error('ERROR', err.message),\n   *   () => console.log('COMPLETE', 'Query executed')\n   * )\n   * @example <caption>Flatten array of rows</caption>\n   * rxClient.query(\n   *   'select * from main',\n   *   result => Observable.from(result.rows.slice())\n   * ).subscribe(\n   *   row => console.log('NEXT', row),\n   *   err => console.error('ERROR', err.message),\n   *   () => console.log('COMPLETE', 'Query executed')\n   * )\n   *\n   * @see {@link RxClient#queryRow}\n   * @see {@link RxClient#queryRows}\n   * @see {@link RxClient#queryRowsSeq}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array|function(x: Result): *} [values] Array of query arguments or projection function.\n   * @param {function(x: Result): *} [projectFunction] A function which takes the query {@link Result}\n   *      and maps it ta the another value or inner {@link Observable}.\n   *\n   * @return {Observable} Returns {@link Observable} sequence of query {@link Result} or\n   *      whatever returned by the `projectFunction`.\n   */\n  query (queryText, values, projectFunction) {\n    if (typeof values === 'function') {\n      projectFunction = values\n    }\n\n    this._querySource = (this._querySource || this.connect())\n      .concatMap(() => {\n        const query = Observable.bindNodeCallback(::this._client.query)\n\n        return query(queryText, values)\n      })\n      .do(\n        () => {\n          util.log('RxClient: query executed', [ queryText, this._txLevel ])\n          this._commitTxLevel()\n        },\n        () => {\n          util.err('RxClient: query executed', [ queryText, this._txLevel ])\n          this._rollbackTxLevel()\n          this._querySource = undefined\n        }\n      )\n      .publishReplay()\n      .refCount()\n\n    let source = this._querySource\n    if (projectFunction) {\n      source = source.map(result => {\n        const projectedValue = projectFunction(result)\n\n        return projectedValue instanceof Observable\n          ? projectedValue\n          : Observable.of(projectedValue)\n      }).concatAll()\n    }\n\n    return source\n  }\n\n  /**\n   * Executes query and maps the query {@link Result} object to the first returned row.\n   *\n   * @see {@link RxClient#query}\n   * @see {@link RxClient#queryRows}\n   * @see {@link RxClient#queryRowsSeq}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} Single element {@link Observable} sequence of the first returned row.\n   */\n  queryRow (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice().shift())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to the array of rows.\n   *\n   * @see {@link RxClient#query}\n   * @see {@link RxClient#queryRow}\n   * @see {@link RxClient#queryRowsSeq}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Array<Object>>} {@link Observable} sequence of array of rows.\n   */\n  queryRows (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to {@link Observable} sequence of returned rows.\n   *\n   * @see {@link RxClient#query}\n   * @see {@link RxClient#queryRow}\n   * @see {@link RxClient#queryRows}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} {@link Observable} sequence of rows returned by the query.\n   */\n  queryRowsSeq (queryText, values) {\n    return this.query(queryText, values, result => Observable.from(result.rows.slice()))\n  }\n\n  /**\n   * Opens new transaction on the top level when {@link RxClient#txLevel} equals to 0,\n   * or creates savepoints for nested transactions when {@link RxClient#txLevel} more than 1 (i.e partial rollback).\n   * See PostgreSQL documentation for known limitations of savepoints.\n   *\n   * @example <caption>Execute SQL queries in transactions</caption>\n   * // RxClient#txLevel = 0\n   * // begin new transaction\n   * rxClient.begin() // RxClient#txLevel = 1\n   *   .concat(rxClient.queryRow(\n   *     'insert into main (name) values ($1) returning *',\n   *     [ 'qwerty' ]\n   *   ))\n   *   // work with inserted record\n   *   .mergeMap(\n   *     insertedRow => Observable.concat(\n   *       rxClient.begin(), // RxClient#txLevel = 2\n   *       // try to execute invalid query\n   *       rxClient.queryRow(\n   *         'update main set (id, name) = ($1, $2) where id = $3 returning *',\n   *         [ 1, 'qwerty new name', insertedRow.id ]\n   *       ),\n   *       rxClient.commit() // RxClient#txLevel = 1\n   *     ).catch(() => rxClient.rollback(insertedRow)) // rollback to the last savepoint if query failed\n   *   )\n   *   // commit the top level transaction\n   *   .mergeMap(row => rxClient.commit(row, true)) // RxClient#txLevel = 0\n   *   .subscribe(\n   *     row => console.log('NEXT', row),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#commit}\n   * @see {@link RxClient#rollback}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   *\n   * @return {Observable} Returns empty {@link Observable} sequence that completes\n   *      when transaction successfully opened or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @experimental\n   */\n  begin (mapTo) {\n    assert(this._txLevel >= 0, 'Current transaction level >= 0')\n\n    const begin = () => {\n      this._commitTxLevel()\n\n      let query\n      if (this._txLevel === 0) {\n        query = 'begin'\n      } else {\n        query = `savepoint point_${this._txLevel}`\n      }\n\n      ++this._txLevel\n\n      return this.query(query)\n    }\n\n    let source = begin()\n    if (mapTo != null) {\n      source = source.mapTo(mapTo)\n    } else {\n      source = source.ignoreElements()\n    }\n\n    return source\n  }\n\n  /**\n   * Commits current transaction when {@link RxClient#txLevel} equals to 1\n   * or releases last savepoint when {@link RxClient#txLevel} more that 1.\n   * Call with `force = true` commits current transaction with all savepoints\n   * from any depth level.\n   *\n   * @example <caption>Execute SQL queries in transactions</caption>\n   * // RxClient#txLevel = 0\n   * // begin new transaction\n   * rxClient.begin() // RxClient#txLevel = 1\n   *   .concat(rxClient.queryRow(\n   *     'insert into main (name) values ($1) returning *',\n   *     [ 'qwerty' ]\n   *   ))\n   *   // work with inserted record\n   *   .mergeMap(\n   *     insertedRow => Observable.concat(\n   *       rxClient.begin(), // RxClient#txLevel = 2\n   *       // try to execute invalid query\n   *       rxClient.queryRow(\n   *         'update main set (id, name) = ($1, $2) where id = $3 returning *',\n   *         [ 1, 'qwerty new name', insertedRow.id ]\n   *       ),\n   *       rxClient.commit() // RxClient#txLevel = 1\n   *     ).catch(() => rxClient.rollback(insertedRow)) // rollback to the last savepoint if query failed\n   *   )\n   *   // commit the top level transaction\n   *   .mergeMap(row => rxClient.commit(row, true)) // RxClient#txLevel = 0\n   *   .subscribe(\n   *     row => console.log('NEXT', row),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#begin}\n   * @see {@link RxClient#rollback}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   * @param {boolean} [force] If `true` commits transaction with all savepoints.\n   *\n   * @return {Observable} Returns empty {@link Observable} sequence that completes\n   *      when transaction successfully committed or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @throws {RxClientError} Throws when transaction doesn't exists.\n   *\n   * @experimental\n   */\n  commit (mapTo, force) {\n    assert(this._txLevel >= 0, 'Current transaction level >= 0')\n\n    const commit = () => {\n      if (this._txLevel === 0) {\n        throw new RxClientError('The transaction is not opened on the client')\n      }\n\n      this._commitTxLevel()\n\n      let query\n      if (this._txLevel === 1 || force) {\n        query = 'commit'\n        this._txLevel = 0\n      } else {\n        query = `release savepoint point_${--this._txLevel}`\n      }\n\n      return this.query(query)\n    }\n\n    let source = commit()\n    if (mapTo != null) {\n      source = source.mapTo(mapTo)\n    } else {\n      source = source.ignoreElements()\n    }\n\n    return source\n  }\n\n  /**\n   * Rolls back current transaction when {@link RxClient#txLevel} equals to 1\n   * or rolls back to the last savepoint when {@link RxClient#txLevel} more that 1.\n   * Call with `force = true` rolls back current transaction with all savepoints\n   * from any depth level.\n   *\n   * @example <caption>Execute SQL queries in transactions</caption>\n   * // RxClient#txLevel = 0\n   * // begin new transaction\n   * rxClient.begin() // RxClient#txLevel = 1\n   *   .concat(rxClient.queryRow(\n   *     'insert into main (name) values ($1) returning *',\n   *     [ 'qwerty' ]\n   *   ))\n   *   // work with inserted record\n   *   .mergeMap(\n   *     insertedRow => Observable.concat(\n   *       rxClient.begin(), // RxClient#txLevel = 2\n   *       // try to execute invalid query\n   *       rxClient.queryRow(\n   *         'update main set (id, name) = ($1, $2) where id = $3 returning *',\n   *         [ 1, 'qwerty new name', insertedRow.id ]\n   *       ),\n   *       rxClient.commit() // RxClient#txLevel = 1\n   *     ).catch(() => rxClient.rollback(insertedRow)) // rollback to the last savepoint if query failed\n   *   )\n   *   // commit the top level transaction\n   *   .mergeMap(row => rxClient.commit(row, true)) // RxClient#txLevel = 0\n   *   .subscribe(\n   *     row => console.log('NEXT', row),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#begin}\n   * @see {@link RxClient#commit}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   * @param {boolean} [force] If `true` rolls back transaction with all savepoints.\n   *\n   * @return {Observable} Returns empty {@link Observable} sequence that completes\n   *      when transaction successfully rolled back or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @throws {RxClientError} Throws when transaction doesn't exists.\n   *\n   * @experimental\n   */\n  rollback (mapTo, force) {\n    assert(this._txLevel >= 0, 'Current transaction level >= 0')\n\n    const rollback = () => {\n      if (this._txLevel === 0) {\n        throw new RxClientError('The transaction is not opened on the client')\n      }\n\n      this._commitTxLevel()\n\n      let query\n      if (this._txLevel === 1 || force) {\n        query = 'rollback'\n        this._txLevel = 0\n      } else {\n        query = `rollback to savepoint point_${--this._txLevel}`\n      }\n\n      return this.query(query)\n    }\n\n    let source = rollback()\n    if (mapTo != null) {\n      source = source.mapTo(mapTo)\n    } else {\n      source = source.ignoreElements()\n    }\n\n    return source\n  }\n\n  /**\n   * @private\n   */\n  _commitTxLevel () {\n    this._savedTxLevel = this._txLevel\n  }\n\n  /**\n   * @private\n   */\n  _rollbackTxLevel () {\n    this._txLevel = this._savedTxLevel\n  }\n}\n"]}