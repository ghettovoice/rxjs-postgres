{"version":3,"sources":["../../src/adapters/RxPool.js"],"names":["util","RxPool","pool","Pool","_pool","fromPromise","connect","flatMap","rxClient","client","release","err","log","mapTo","do","end","map","queryText","values","projectFunction","mergeMap","query","undefined","result","rows","slice","shift","from"],"mappings":";;;;;;;;AAAA;;;;AACA;;AACA;;;;AACA;;AACA;;IAAYA,I;;;;;;;;AAEZ;;;IAGqBC,M;AACnB;;;AAGA,kBAAaC,IAAb,EAAmB;AAAA;;AACjB,QAAI,EAAEA,gBAAgB,aAAGC,IAArB,CAAJ,EAAgC;AAC9B,YAAM,wBAAgB,qCAAhB,CAAN;AACD;;AAED;;;;AAIA,SAAKC,KAAL,GAAaF,IAAb;AACD;;AAED;;;;;;;;;AAOA;;;;;;;;;;;8BAWW;AACT,aAAO,iBAAWG,WAAX,CAAuB,KAAKD,KAAL,CAAWE,OAAX,EAAvB,EACJC,OADI,CACI,kBAAU;AACjB,YAAMC,WAAW,uBAAaC,MAAb,CAAjB;;AAEAD,iBAASE,OAAT,GAAmB,UAAUC,GAAV,EAAe;AAChCX,eAAKY,GAAL,CAAS,mBAAT;;AAEA,iBAAOJ,SAASE,OAAhB;AACAD,iBAAOC,OAAP,CAAeC,GAAf;AACD,SALD;;AAOA,eAAOH,SAASF,OAAT,GAAmBO,KAAnB,CAAyBL,QAAzB,CAAP;AACD,OAZI,EAaJM,EAbI,CAaD;AAAA,eAAMd,KAAKY,GAAL,CAAS,0BAAT,CAAN;AAAA,OAbC,CAAP;AAcD;;AAED;;;;;;;;;2BAMQ;AACN,aAAO,KAAKN,OAAL,EAAP;AACD;;AAED;;;;;;0BAGO;AAAA;;AACL,aAAO,iBAAWD,WAAX,CAAuB,KAAKD,KAAL,CAAWW,GAAX,EAAvB,EACJC,GADI,CACA;AAAA;AAAA,OADA,EAEJF,EAFI,CAED;AAAA,eAAMd,KAAKY,GAAL,CAAS,oBAAT,CAAN;AAAA,OAFC,CAAP;AAGD;;AAED;;;;;;;;;;;;;;;;;;;;;0BAkBOK,S,EAAWC,M,EAAQC,e,EAAiB;AACzC,aAAO,KAAKb,OAAL,GACJc,QADI,CAEH;AAAA,eAAUX,OAAOY,KAAP,CAAaJ,SAAb,EAAwBC,MAAxB,EAAgCC,eAAhC,EACPL,EADO,CACJQ,SADI,EACSb,OAAOC,OADhB,MACSD,MADT,GAC2BA,OAAOC,OADlC,MAC2BD,MAD3B,EAAV;AAAA,OAFG,CAAP;AAKD;;AAED;;;;;;;;;;;;;;;;6BAaUQ,S,EAAWC,M,EAAQ;AAC3B,aAAO,KAAKG,KAAL,CAAWJ,SAAX,EAAsBC,MAAtB,EAA8B;AAAA,eAAUK,OAAOC,IAAP,CAAYC,KAAZ,GAAoBC,KAApB,EAAV;AAAA,OAA9B,CAAP;AACD;;AAED;;;;;;;;;;;;;;;;8BAaWT,S,EAAWC,M,EAAQ;AAC5B,aAAO,KAAKG,KAAL,CAAWJ,SAAX,EAAsBC,MAAtB,EAA8B;AAAA,eAAUK,OAAOC,IAAP,CAAYC,KAAZ,EAAV;AAAA,OAA9B,CAAP;AACD;;AAED;;;;;;;;;;;;;;;;iCAacR,S,EAAWC,M,EAAQ;AAC/B,aAAO,KAAKG,KAAL,CAAWJ,SAAX,EAAsBC,MAAtB,EAA8B;AAAA,eAAU,iBAAWS,IAAX,CAAgBJ,OAAOC,IAAP,CAAYC,KAAZ,EAAhB,CAAV;AAAA,OAA9B,CAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;wBAnLY;AACV,aAAO,KAAKrB,KAAZ;AACD;;;;;;kBArBkBH,M","file":"RxPool.js","sourcesContent":["import pg from 'pg'\nimport { Observable } from 'rxjs'\nimport RxClient from './RxClient'\nimport { RxPoolError } from '../errors'\nimport * as util from '../util'\n\n/**\n * Standalone RxJs adapter for `pg.Pool`.\n */\nexport default class RxPool {\n  /**\n   * @param {Pool} pool\n   */\n  constructor (pool) {\n    if (!(pool instanceof pg.Pool)) {\n      throw new RxPoolError('Pool must be instance of Pool class')\n    }\n\n    /**\n     * @type {Pool}\n     * @private\n     */\n    this._pool = pool\n  }\n\n  /**\n   * @return {Pool}\n   */\n  get pool () {\n    return this._pool\n  }\n\n  /**\n   * Acquires {@link Client} from the {@link Pool} and wraps it into {@link RxClient} adapter.\n   *\n   * @alias {@link RxPool#take}\n   *\n   * @see {@link RxPool#end}\n   * @see {@link RxClient}\n   *\n   * @return {Observable<RxClient>} Returns single element {@link Observable} sequence\n   *    of the connected {@link RxClient}\n   */\n  connect () {\n    return Observable.fromPromise(this._pool.connect())\n      .flatMap(client => {\n        const rxClient = new RxClient(client)\n\n        rxClient.release = function (err) {\n          util.log('RxClient: release')\n\n          delete rxClient.release\n          client.release(err)\n        }\n\n        return rxClient.connect().mapTo(rxClient)\n      })\n      .do(() => util.log('RxPool: client connected'))\n  }\n\n  /**\n   * Alias of the {@link RxPool#connect} method.\n   *\n   * @return {Observable<RxClient>} Returns single element {@link Observable} sequence\n   *    of the connected {@link RxClient}.\n   */\n  take () {\n    return this.connect()\n  }\n\n  /**\n   * @return {Observable<RxPool>}\n   */\n  end () {\n    return Observable.fromPromise(this._pool.end())\n      .map(() => this)\n      .do(() => util.log('RxPool: pool ended'))\n  }\n\n  /**\n   * Executes SQL query with arguments and returns {@link Observable} sequence of the query {@link Result} object.\n   * You can pass result projection function as second or third argument to map {@link Result} object to\n   * another value that will be emitted by the result {@link Observable}.\n   *\n   * @see {@link RxPool#queryRow}\n   * @see {@link RxPool#queryRows}\n   * @see {@link RxPool#queryRowsSeq}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array|function(x: Result): *} [values] Array of query arguments or projection function.\n   * @param {function(x: Result): *} [projectFunction] A function which takes the query {@link Result}\n   *      and maps it ta the another value or inner {@link Observable}.\n   *\n   * @return {Observable} Returns {@link Observable} sequence of query {@link Result} or\n   *      whatever returned by the `projectFunction`.\n   */\n  query (queryText, values, projectFunction) {\n    return this.connect()\n      .mergeMap(\n        client => client.query(queryText, values, projectFunction)\n          .do(undefined, ::client.release, ::client.release)\n      )\n  }\n\n  /**\n   * Executes query and maps the query {@link Result} object to the first returned row.\n   *\n   * @see {@link RxPool#query}\n   * @see {@link RxPool#queryRows}\n   * @see {@link RxPool#queryRowsSeq}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} Single element {@link Observable} sequence of the first returned row.\n   */\n  queryRow (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice().shift())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to the array of rows.\n   *\n   * @see {@link RxPool#query}\n   * @see {@link RxPool#queryRow}\n   * @see {@link RxPool#queryRowsSeq}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Array<Object>>} {@link Observable} sequence of array of rows.\n   */\n  queryRows (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to {@link Observable} sequence of returned rows.\n   *\n   * @see {@link RxPool#query}\n   * @see {@link RxPool#queryRow}\n   * @see {@link RxPool#queryRows}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} {@link Observable} sequence of rows returned by the query.\n   */\n  queryRowsSeq (queryText, values) {\n    return this.query(queryText, values, result => Observable.from(result.rows.slice()))\n  }\n\n  // /**\n  //  * @return {Observable<RxPool>}\n  //  */\n  // begin() {\n  //     this._tclientSource = (this._tclientSource || this.connect())\n  //         .flatMap(rxClient => rxClient.begin())\n  //         .shareReplay(1);\n  //\n  //     return this._tclientSource.map(() => this);\n  // }\n  //\n  // /**\n  //  * @param {boolean} [force] Commit transaction with all savepoints.\n  //  * @return {Observable<RxPool>}\n  //  * @throws {RxPoolError}\n  //  */\n  // commit(force) {\n  //     if (!this._tclientSource) {\n  //         throw new RxPoolError('Client with open transaction does not exists');\n  //     }\n  //\n  //     this._tclientSource = this._tclientSource.flatMap(rxClient => rxClient.commit(force))\n  //         .do(rxClient => {\n  //             if (rxClient.txLevel === 0) {\n  //                 this._tclientSource = undefined;\n  //             }\n  //         })\n  //         .shareReplay(1);\n  //\n  //     return this._tclientSource.map(() => this);\n  // }\n  //\n  // /**\n  //  * @param {boolean} [force] Rollback transaction with all savepoints.\n  //  * @return {Observable<RxPool>}\n  //  * @throws {RxPoolError}\n  //  */\n  // rollback(force) {\n  //     if (!this._tclientSource) {\n  //         throw new RxPoolError('Client with open transaction does not exists');\n  //     }\n  //\n  //     this._tclientSource = this._tclientSource.flatMap(rxClient => rxClient.rollback(force))\n  //         .do(rxClient => {\n  //             if (rxClient.txLevel === 0) {\n  //                 this._tclientSource = undefined;\n  //             }\n  //         })\n  //         .shareReplay(1);\n  //\n  //     return this._tclientSource.map(() => this);\n  // }\n}\n"]}