{"version":3,"sources":["../../src/adapters/RxPool.js"],"names":["util","RxPool","pool","Pool","_pool","autoRelease","fromPromise","connect","flatMap","rxClient","client","release","err","log","clientSource","mapTo","do","undefined","end","map","queryText","values","projectFunction","mergeMap","query","result","rows","slice","shift","from"],"mappings":"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","file":"RxPool.js","sourcesContent":["import pg from 'pg'\nimport { Observable } from 'rxjs'\nimport RxClient from './RxClient'\nimport { RxPoolError } from '../errors'\nimport * as util from '../util'\n\n/**\n * Standalone RxJs adapter for `pg.Pool`.\n */\nexport default class RxPool {\n  /**\n   * @param {Pool} pool\n   */\n  constructor (pool) {\n    if (!(pool instanceof pg.Pool)) {\n      throw new RxPoolError('Pool must be instance of Pool class')\n    }\n\n    /**\n     * @type {Pool}\n     * @private\n     */\n    this._pool = pool\n  }\n\n  /**\n   * @return {Pool}\n   */\n  get pool () {\n    return this._pool\n  }\n\n  /**\n   * Acquires {@link Client} from the {@link Pool} and wraps it into {@link RxClient} adapter.\n   *\n   * @alias {@link RxPool#take}\n   *\n   * @see {@link RxPool#end}\n   * @see {@link RxClient}\n   *\n   * @param {boolean} [autoRelease=true]\n   * @return {Observable<RxClient>} Returns single element {@link Observable} sequence\n   *    of the connected {@link RxClient}\n   */\n  connect (autoRelease = true) {\n    return Observable.fromPromise(this._pool.connect())\n      .flatMap(client => {\n        const rxClient = new RxClient(client)\n\n        rxClient.release = function (err) {\n          util.log('RxClient: release')\n\n          delete rxClient.release\n          client.release(err)\n        }\n\n        let clientSource = rxClient.connect().mapTo(rxClient)\n\n        if (autoRelease) clientSource = clientSource.do(undefined, ::rxClient.release, ::rxClient.release)\n\n        return clientSource\n      })\n      .do(() => util.log('RxPool: client connected'))\n  }\n\n  /**\n   * Alias of the {@link RxPool#connect} method.\n   *\n   * @return {Observable<RxClient>} Returns single element {@link Observable} sequence\n   *    of the connected {@link RxClient}.\n   */\n  take () {\n    return this.connect()\n  }\n\n  /**\n   * @return {Observable<RxPool>}\n   */\n  end () {\n    return Observable.fromPromise(this._pool.end())\n      .map(() => this)\n      .do(() => util.log('RxPool: pool ended'))\n  }\n\n  /**\n   * Executes SQL query with arguments and returns {@link Observable} sequence of the query {@link Result} object.\n   * You can pass result projection function as second or third argument to map {@link Result} object to\n   * another value that will be emitted by the result {@link Observable}.\n   *\n   * @see {@link RxPool#queryRow}\n   * @see {@link RxPool#queryRows}\n   * @see {@link RxPool#queryRowsSeq}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array|function(x: Result): *} [values] Array of query arguments or projection function.\n   * @param {function(x: Result): *} [projectFunction] A function which takes the query {@link Result}\n   *      and maps it ta the another value or inner {@link Observable}.\n   *\n   * @return {Observable} Returns {@link Observable} sequence of query {@link Result} or\n   *      whatever returned by the `projectFunction`.\n   */\n  query (queryText, values, projectFunction) {\n    return this.connect()\n      .mergeMap(\n        client => client.query(queryText, values, projectFunction)\n          // .do(undefined, ::client.release, ::client.release)\n      )\n  }\n\n  /**\n   * Executes query and maps the query {@link Result} object to the first returned row.\n   *\n   * @see {@link RxPool#query}\n   * @see {@link RxPool#queryRows}\n   * @see {@link RxPool#queryRowsSeq}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} Single element {@link Observable} sequence of the first returned row.\n   */\n  queryRow (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice().shift())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to the array of rows.\n   *\n   * @see {@link RxPool#query}\n   * @see {@link RxPool#queryRow}\n   * @see {@link RxPool#queryRowsSeq}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Array<Object>>} {@link Observable} sequence of array of rows.\n   */\n  queryRows (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to {@link Observable} sequence of returned rows.\n   *\n   * @see {@link RxPool#query}\n   * @see {@link RxPool#queryRow}\n   * @see {@link RxPool#queryRows}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} {@link Observable} sequence of rows returned by the query.\n   */\n  queryRowsSeq (queryText, values) {\n    return this.query(queryText, values, result => Observable.from(result.rows.slice()))\n  }\n\n  // /**\n  //  * @return {Observable<RxPool>}\n  //  */\n  // begin() {\n  //     this._tclientSource = (this._tclientSource || this.connect())\n  //         .flatMap(rxClient => rxClient.begin())\n  //         .shareReplay(1);\n  //\n  //     return this._tclientSource.map(() => this);\n  // }\n  //\n  // /**\n  //  * @param {boolean} [force] Commit transaction with all savepoints.\n  //  * @return {Observable<RxPool>}\n  //  * @throws {RxPoolError}\n  //  */\n  // commit(force) {\n  //     if (!this._tclientSource) {\n  //         throw new RxPoolError('Client with open transaction does not exists');\n  //     }\n  //\n  //     this._tclientSource = this._tclientSource.flatMap(rxClient => rxClient.commit(force))\n  //         .do(rxClient => {\n  //             if (rxClient.txLevel === 0) {\n  //                 this._tclientSource = undefined;\n  //             }\n  //         })\n  //         .shareReplay(1);\n  //\n  //     return this._tclientSource.map(() => this);\n  // }\n  //\n  // /**\n  //  * @param {boolean} [force] Rollback transaction with all savepoints.\n  //  * @return {Observable<RxPool>}\n  //  * @throws {RxPoolError}\n  //  */\n  // rollback(force) {\n  //     if (!this._tclientSource) {\n  //         throw new RxPoolError('Client with open transaction does not exists');\n  //     }\n  //\n  //     this._tclientSource = this._tclientSource.flatMap(rxClient => rxClient.rollback(force))\n  //         .do(rxClient => {\n  //             if (rxClient.txLevel === 0) {\n  //                 this._tclientSource = undefined;\n  //             }\n  //         })\n  //         .shareReplay(1);\n  //\n  //     return this._tclientSource.map(() => this);\n  // }\n}\n"]}