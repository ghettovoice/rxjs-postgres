{"version":3,"sources":["../../src/adapters/RxPool.js"],"names":["util","RxPool","pool","Pool","_pool","_txClientSource","undefined","_errorSource","fromEvent","autoRelease","fromPromise","connect","flatMap","rxClient","client","release","err","log","clientSource","mapTo","do","end","finally","queryText","values","projectFunction","mergeMap","query","result","rows","slice","shift","from","begin","publishReplay","refCount"],"mappings":"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","file":"RxPool.js","sourcesContent":["import pg from 'pg'\nimport { Observable } from 'rxjs'\nimport RxClient from './RxClient'\nimport { RxPoolError } from '../errors'\nimport * as util from '../util'\n\n/**\n * Standalone adapter for {@link Pool} class with Reactive API.\n *\n * @see {@link RxClient}\n * @see {@link Client}\n */\nexport default class RxPool {\n  /**\n   * @param {Pool} pool Instance of {@link Pool}.\n   *\n   * @throws {RxClientError} Throws when called with invalid arguments.\n   * @throws {TypeError} Throws when called as function.\n   */\n  constructor (pool) {\n    if (!(pool instanceof pg.Pool)) {\n      throw new RxPoolError('Pool must be instance of Pool class')\n    }\n\n    /**\n     * @type {Pool}\n     * @private\n     */\n    this._pool = pool\n    /**\n     * @type {Observable<RxClient>}\n     * @private\n     */\n    this._txClientSource = undefined\n    /**\n     * @type {Observable}\n     * @private\n     */\n    this._errorSource = Observable.fromEvent(this._pool, 'error')\n  }\n\n  /**\n   * @type {Pool} Instance of {@link Pool}.\n   */\n  get pool () {\n    return this._pool\n  }\n\n  /**\n   * Errors hot observable. Use it to subscribe to the pool errors.\n   *\n   * @see {@link Client}\n   *\n   * @type {Observable<Error>}\n   */\n  get errors () {\n    return this._errorSource\n  }\n\n  /**\n   * Acquires {@link Client} from the {@link Pool} and wraps it into {@link RxClient} adapter.\n   *\n   * @alias {@link RxPool#take}\n   *\n   * @see {@link RxPool#end}\n   * @see {@link RxClient}\n   *\n   * @param {boolean} [autoRelease=true] Release client after complete.\n   * @return {Observable<RxClient>} Returns single element {@link Observable} sequence\n   *    of the connected {@link RxClient}\n   */\n  connect (autoRelease = true) {\n    return Observable.fromPromise(this._pool.connect())\n      .flatMap(client => {\n        const rxClient = new RxClient(client)\n\n        rxClient.release = function (err) {\n          util.log('RxClient: release')\n\n          delete rxClient.release\n          client.release(err)\n        }\n\n        let clientSource = rxClient.connect().mapTo(rxClient)\n\n        if (autoRelease) clientSource = clientSource.do(undefined, ::rxClient.release, ::rxClient.release)\n\n        return clientSource\n      })\n      .do(() => util.log('RxPool: client connected'))\n  }\n\n  /**\n   * Alias of the {@link RxPool#connect} method.\n   *\n   * @return {Observable<RxClient>} Returns single element {@link Observable} sequence\n   *    of the connected {@link RxClient}.\n   */\n  take () {\n    return this.connect()\n  }\n\n  /**\n   * @return {Observable<boolean>}\n   */\n  end () {\n    return Observable.fromPromise(this._pool.end())\n      .mapTo(true)\n      .finally(() => {\n        this._txClientSource = undefined\n      })\n      .do(() => util.log('RxPool: pool ended'))\n  }\n\n  /**\n   * Executes SQL query with arguments and returns {@link Observable} sequence of the query {@link Result} object.\n   * You can pass result projection function as second or third argument to map {@link Result} object to\n   * another value that will be emitted by the result {@link Observable}.\n   *\n   * @example <caption>Simple query with arguments</caption>\n   * rxPool.query('select * from main where id = $1', [ 1 ] )\n   *   .subscribe(\n   *     result => console.log('NEXT', result),\n   *     err => console.error('ERROR', err.message),\n   *     () => console.log('COMPLETE')\n   *   )\n   *\n   * @see {@link RxPool#queryRow}\n   * @see {@link RxPool#queryRows}\n   * @see {@link RxPool#queryRowsSeq}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array|function(x: Result): *} [values] Array of query arguments or projection function.\n   * @param {function(x: Result): *} [projectFunction] A function which takes the query {@link Result}\n   *      and maps it ta the another value or inner {@link Observable}.\n   *\n   * @return {Observable} Returns {@link Observable} sequence of query {@link Result} or\n   *      whatever returned by the `projectFunction`.\n   */\n  query (queryText, values, projectFunction) {\n    return (this._txClientSource || this.connect())\n      .mergeMap(client => client.query(queryText, values, projectFunction))\n  }\n\n  /**\n   * Executes query and maps the query {@link Result} object to the first returned row.\n   *\n   * @see {@link RxPool#query}\n   * @see {@link RxPool#queryRows}\n   * @see {@link RxPool#queryRowsSeq}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} Single element {@link Observable} sequence of the first returned row.\n   */\n  queryRow (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice().shift())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to the array of rows.\n   *\n   * @see {@link RxPool#query}\n   * @see {@link RxPool#queryRow}\n   * @see {@link RxPool#queryRowsSeq}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Array<Object>>} {@link Observable} sequence of array of rows.\n   */\n  queryRows (queryText, values) {\n    return this.query(queryText, values, result => result.rows.slice())\n  }\n\n  /**\n   * Executes query and maps query {@link Result} object to {@link Observable} sequence of returned rows.\n   *\n   * @see {@link RxPool#query}\n   * @see {@link RxPool#queryRow}\n   * @see {@link RxPool#queryRows}\n   * @see {@link RxClient#query}\n   *\n   * @param {string} queryText SQL string.\n   * @param {Array} [values] Array of query arguments.\n   *\n   * @return {Observable<Object>} {@link Observable} sequence of rows returned by the query.\n   */\n  queryRowsSeq (queryText, values) {\n    return this.query(queryText, values, result => Observable.from(result.rows.slice()))\n  }\n\n  /**\n   * Opens new transaction on the top level when {@link RxClient#txLevel} equals to 0,\n   * or creates savepoints for nested transactions when {@link RxClient#txLevel} more than 1 (i.e partial rollback).\n   * See PostgreSQL documentation for known limitations of savepoints.\n   *\n   * @see {@link RxClient#txLevel}\n   * @see {@link RxClient#commit}\n   * @see {@link RxClient#rollback}\n   * @see https://www.postgresql.org/docs/current/static/tutorial-transactions.html\n   *\n   * @param {*} [mapTo] If defined will be emitted by the returned {@link Observable}\n   *\n   * @return {Observable} Returns empty {@link Observable} sequence that completes\n   *      when transaction successfully opened or {@link Observable} sequence of\n   *      whatever passed as `mapTo` argument.\n   *\n   * @experimental\n   */\n  begin (mapTo) {\n    this._txClientSource = (this._txClientSource || this.connect())\n      .mergeMap(rxClient => rxClient.begin(mapTo))\n      .publishReplay()\n      .refCount()\n\n    return this._txClientSource\n  }\n\n  // /**\n  //  * @param {boolean} [force] Commit transaction with all savepoints.\n  //  * @return {Observable<RxPool>}\n  //  *\n  //  * @throws {RxPoolError}\n  //  *\n  //  * @experimental\n  //  */\n  // commit (force) {\n  //   if (!this._tclientSource) {\n  //     throw new RxPoolError('Client with open transaction does not exists')\n  //   }\n  //\n  //   this._tclientSource = this._tclientSource.flatMap(rxClient => rxClient.commit(force))\n  //     .do(rxClient => {\n  //       if (rxClient.txLevel === 0) {\n  //         this._tclientSource = undefined\n  //       }\n  //     })\n  //     .shareReplay(1)\n  //\n  //   return this._tclientSource.map(() => this)\n  // }\n  //\n  // /**\n  //  * @param {boolean} [force] Rollback transaction with all savepoints.\n  //  * @return {Observable<RxPool>}\n  //  *\n  //  * @throws {RxPoolError}\n  //  *\n  //  * @experimental\n  //  */\n  // rollback (force) {\n  //   if (!this._tclientSource) {\n  //     throw new RxPoolError('Client with open transaction does not exists')\n  //   }\n  //\n  //   this._tclientSource = this._tclientSource.flatMap(rxClient => rxClient.rollback(force))\n  //     .do(rxClient => {\n  //       if (rxClient.txLevel === 0) {\n  //         this._tclientSource = undefined\n  //       }\n  //     })\n  //     .shareReplay(1)\n  //\n  //   return this._tclientSource.map(() => this)\n  // }\n}\n"]}